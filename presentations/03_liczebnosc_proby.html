<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Metoda reprezentacyjna</title>
    <meta charset="utf-8" />
    <meta name="author" content="© Łukasz Wawrowski" />
    <script src="libs/header-attrs-2.3/header-attrs.js"></script>
    <script src="libs/htmlwidgets-1.5.1/htmlwidgets.js"></script>
    <script src="libs/plotly-binding-4.9.2.1/plotly.js"></script>
    <script src="libs/typedarray-0.1/typedarray.min.js"></script>
    <script src="libs/jquery-1.11.3/jquery.min.js"></script>
    <link href="libs/crosstalk-1.1.0.1/css/crosstalk.css" rel="stylesheet" />
    <script src="libs/crosstalk-1.1.0.1/js/crosstalk.min.js"></script>
    <link href="libs/plotly-htmlwidgets-css-1.52.2/plotly-htmlwidgets.css" rel="stylesheet" />
    <script src="libs/plotly-main-1.52.2/plotly-latest.min.js"></script>
    <link rel="stylesheet" href="default.css" type="text/css" />
    <link rel="stylesheet" href="default-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Metoda reprezentacyjna
## Minimalna liczebność próby
### © Łukasz Wawrowski

---




# Minimalna liczebność próby

Minimalna liczebność próby (MLP) informuje ile jednostek należy przebadać, aby maksymalny błąd oszacowania (na poziomie ufności `\(1–\alpha\)`) wyniósł co najwyżej `\(d\)`.

Przy większej liczbie jednostek oszacowanie będzie bardziej trafne (przedział ufności będzie węższy). Z drugiej strony koszty badania rosną wraz ze wzrostem liczebności próby.

Szukamy kompromisu pomiędzy dokładnością, a liczbą badanych jednostek.

---

# Podejście kosztowe

Badane jest tyle jednostek na ile pozwala założony budżet.

`$$n = \frac{\text{budżet} - \text{koszty stałe}}{\text{koszt jednostkowy}}$$`

Przykład:

`$$n=\frac{25000-5000}{20}=1000$$`

W tym podejściu nie bierzemy pod uwagę błędu oszacowania.

---

## Podejścia oparte o przedział ufności

Do wyznaczenia minimalnej liczebności niezbędne jest ustalenie:

- poziomu prawdopodobieństwa (poziomu istotności) - `\(\alpha\)`
- maksymalnego dopuszczalnego błędu pomiaru - `\(d\)`
- odsetek/odchylenie standardowe z badania pilotażowego - `\(p_0\)` lub `\(\sigma\)`

---

# Przedział ufności dla średniej

`$$P\left\{\bar{X}-z_{(1-\alpha/2)}\frac{\sigma}{\sqrt{n}}&lt;m&lt;\bar{X}+z_{(1-\alpha/2)}\frac{\sigma}{\sqrt{n}}\right\}=1-\alpha$$`
gdzie:

- `\(m\)` - prawdziwa wartość średniej w populacji,
- `\(\bar{X}\)` - estymator średniej z próby,
- `\(z_{(1-\alpha/2)}\)` - kwantyl rozkładu normalnego obliczony dla poziomu istotności `\(\alpha\)`,
- `\(\sigma\)` - znane odchylenie standardowe,
- `\(n\)` - liczebność próby.

Błąd oszacowania to wynik odejmowania i dodawania od i do średniej z próby.

--

Przykładowo: przedział ufności czasu pracy w ciągu tygodnia wynosi `\((35,45)\)` godzin. Zatem średnia z próby wynosi 40 godzin, a błąd 5 godzin.

---

### MLP - wyprowadzenie

`$$P\left\{\bar{X}-z_{(1-\alpha/2)}\frac{\sigma}{\sqrt{n}}&lt;m&lt;\bar{X}+z_{(1-\alpha/2)}\frac{\sigma}{\sqrt{n}}\right\}=1-\alpha$$`
Za błąd odpowiada: 

`$$z_{(1-\alpha/2)}\frac{\sigma}{\sqrt{n}}$$`

Chcemy, żeby błąd był mniejszy od tego wyrażenia:

`$$d \geq z_{(1-\alpha/2)}\frac{\sigma}{\sqrt{n}}$$`
Zatem po przekształceniach:

`$$\sqrt{n} \geq z_{(1-\alpha/2)}\frac{\sigma}{d}$$`
Otrzymujemy wzór na minimalną liczebność próby:

`$$n \geq \left(z_{(1-\alpha/2)}\frac{\sigma}{d}\right)^2$$`

---

# MLP - szacowanie średniej (I)

Znane odchylenie standardowe w populacji.

`$$n \geq \left(z_{(1-\alpha/2)} \cdot \frac{\sigma}{d}\right)^2$$`

gdzie: 

- `\(z_{1-\alpha/2}\)` - kwantyl rozkładu normalnego obliczony dla poziomu istotności `\(\alpha\)`
- `\(\sigma\)` - odchylenie standardowe w populacji
- `\(d\)` - maksymalny dopuszczalny błąd pomiaru

---

# MLP - szacowanie średniej (II)

Nieznane odchylenie standardowe w populacji.

`$$n \geq \left(t_{(1-\alpha/2,n_0-1)} \cdot \frac{s}{d}\right)^2$$`

gdzie: 

- `\(t_{(1-\alpha/2,n_0-1)}\)` - kwantyl rozkładu t-Studenta obliczony dla poziomu istotności `\(\alpha\)` i dla stopni swobody `\(n_0-1\)`
- `\(n_0\)` - wielkość próby w badaniu pilotażowym
- `\(s\)` - odchylenie standardowe w badaniu pilotażowym
- `\(d\)` - maksymalny dopuszczalny błąd pomiaru

---

# MLP - szacowanie odsetka (I)

Znany szacunkowy odsetek.

`$$n \geq z_{(1-\alpha/2)}^2 \cdot \frac{p_0(1-p_0)}{d^2}$$`

gdzie: 

- `\(z_{1-\alpha/2}\)` - kwantyl rozkładu normalnego obliczony dla poziomu istotności `\(\alpha\)`
- `\(p_0\)` - znany szacunkowy odsetek
- `\(d\)` - maksymalny dopuszczalny błąd pomiaru


---

# MLP - szacowanie odsetka (II)

Nieznany szacunkowy odsetek.

`$$n \geq z_{(1-\alpha/2)}^2 \cdot \frac{1}{d^2}$$`

gdzie: 

- `\(z_{1-\alpha/2}\)` - kwantyl rozkładu normalnego obliczony dla poziomu istotności `\(\alpha\)`
- `\(d\)` - maksymalny dopuszczalny błąd pomiaru

---

# Wartości kwantyli N(0,1)

| Prawdopodobieństwo | Poziom istotności | Kwantyl rozkł. norm.|
|-------------------:|------------------:|--------------------:|
| 99% (0,99) | 0,01 | 2,58 | 
| 95% (0,95) | 0,05 | 1,96 |
| 90% (0,90) | 0,10 | 1,64 |

Wyznaczanie wartości kwantyli w R:

- `qnorm(p = 1-alfa/2)`
- `qt(p = 1-alfa/2, df = n0-1)`

---

# Zależności - średnia

Prawdopodobieństwo = 95%, odchylenie standardowe = 100

<div id="htmlwidget-e7bb64cfae0b3a43a2b3" style="width:8px;height:6px;" class="plotly html-widget"></div>
<script type="application/json" data-for="htmlwidget-e7bb64cfae0b3a43a2b3">{"x":{"data":[{"x":[0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.11,0.12,0.13,0.14,0.15,0.16,0.17,0.18,0.19,0.2],"y":[384145883,96036471,42682876,24009118,15365836,10670719,7839712,6002280,4742542,3841459,3174760,2667680,2273053,1959928,1707316,1500570,1329225,1185636,1064117,960365],"text":["d: 0.01<br />n: 384145883","d: 0.02<br />n:  96036471","d: 0.03<br />n:  42682876","d: 0.04<br />n:  24009118","d: 0.05<br />n:  15365836","d: 0.06<br />n:  10670719","d: 0.07<br />n:   7839712","d: 0.08<br />n:   6002280","d: 0.09<br />n:   4742542","d: 0.10<br />n:   3841459","d: 0.11<br />n:   3174760","d: 0.12<br />n:   2667680","d: 0.13<br />n:   2273053","d: 0.14<br />n:   1959928","d: 0.15<br />n:   1707316","d: 0.16<br />n:   1500570","d: 0.17<br />n:   1329225","d: 0.18<br />n:   1185636","d: 0.19<br />n:   1064117","d: 0.20<br />n:    960365"],"type":"scatter","mode":"markers","marker":{"autocolorscale":false,"color":"rgba(0,0,0,1)","opacity":1,"size":5.66929133858268,"symbol":"circle","line":{"width":1.88976377952756,"color":"rgba(0,0,0,1)"}},"hoveron":"points","showlegend":false,"xaxis":"x","yaxis":"y","hoverinfo":"text","frame":null}],"layout":{"margin":{"t":25.7412480974125,"r":7.30593607305936,"b":39.6955859969559,"l":78.1735159817352},"font":{"color":"rgba(0,0,0,1)","family":"","size":14.6118721461187},"xaxis":{"domain":[0,1],"automargin":true,"type":"linear","autorange":false,"range":[0.000499999999999999,0.2095],"tickmode":"array","ticktext":["0.05","0.10","0.15","0.20"],"tickvals":[0.05,0.1,0.15,0.2],"categoryorder":"array","categoryarray":["0.05","0.10","0.15","0.20"],"nticks":null,"ticks":"","tickcolor":null,"ticklen":3.65296803652968,"tickwidth":0,"showticklabels":true,"tickfont":{"color":"rgba(77,77,77,1)","family":"","size":11.689497716895},"tickangle":-0,"showline":false,"linecolor":null,"linewidth":0,"showgrid":true,"gridcolor":"rgba(235,235,235,1)","gridwidth":0.66417600664176,"zeroline":false,"anchor":"y","title":{"text":"d","font":{"color":"rgba(0,0,0,1)","family":"","size":14.6118721461187}},"hoverformat":".2f"},"yaxis":{"domain":[0,1],"automargin":true,"type":"linear","autorange":false,"range":[-18198910.9,403305158.9],"tickmode":"array","ticktext":["0","100000000","200000000","300000000","400000000"],"tickvals":[0,100000000,200000000,300000000,400000000],"categoryorder":"array","categoryarray":["0","100000000","200000000","300000000","400000000"],"nticks":null,"ticks":"","tickcolor":null,"ticklen":3.65296803652968,"tickwidth":0,"showticklabels":true,"tickfont":{"color":"rgba(77,77,77,1)","family":"","size":11.689497716895},"tickangle":-0,"showline":false,"linecolor":null,"linewidth":0,"showgrid":true,"gridcolor":"rgba(235,235,235,1)","gridwidth":0.66417600664176,"zeroline":false,"anchor":"x","title":{"text":"n","font":{"color":"rgba(0,0,0,1)","family":"","size":14.6118721461187}},"hoverformat":".2f"},"shapes":[{"type":"rect","fillcolor":null,"line":{"color":null,"width":0,"linetype":[]},"yref":"paper","xref":"paper","x0":0,"x1":1,"y0":0,"y1":1}],"showlegend":false,"legend":{"bgcolor":null,"bordercolor":null,"borderwidth":0,"font":{"color":"rgba(0,0,0,1)","family":"","size":11.689497716895}},"hovermode":"closest","width":8,"height":6,"barmode":"relative"},"config":{"doubleClick":"reset","showSendToCloud":false},"source":"A","attrs":{"31e068844935":{"x":{},"y":{},"type":"scatter"}},"cur_data":"31e068844935","visdat":{"31e068844935":["function (y) ","x"]},"highlight":{"on":"plotly_click","persistent":false,"dynamic":false,"selectize":false,"opacityDim":0.2,"selected":{"opacity":1},"debounce":0},"shinyEvents":["plotly_hover","plotly_click","plotly_selected","plotly_relayout","plotly_brushed","plotly_brushing","plotly_clickannotation","plotly_doubleclick","plotly_deselect","plotly_afterplot","plotly_sunburstclick"],"base_url":"https://plot.ly"},"evals":[],"jsHooks":[]}</script>


---

class: inverse, center, middle

# Pytania?
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "4:3",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
