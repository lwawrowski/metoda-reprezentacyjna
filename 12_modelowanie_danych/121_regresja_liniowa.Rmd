---
title: "Regresja liniowa"
author: "Imię i nazwisko"
date: "7 stycznia 2019"
output: html_document
---

```{r}
library(tidyverse)

dane1 <- data.frame(id1=1:5,
                    x1=c(21,20,22,17,16),
                    y1=c(40,41,42,39,37))

dane2 <- data.frame(id2=1:5,
                    x2=c(21,20,22,17,16),
                    y2=c(40,41,42,39,37))

dane <- expand.grid(id1=dane1$id1, id2=dane2$id2)

dane <- dane[dane$id1!=dane$id2,]

dane_final <- as.data.frame(unique(t(apply(dane[,1:2], 1, sort))))
names(dane_final) <- names(dane)

dane_final <- merge(dane_final, dane1)
dane_final <- merge(dane_final, dane2)

dane_final <- dane_final %>%
  mutate(b=(y1-y2)/(x1-x2),
         w=(x1-x2)^2)

mean(dane_final$b)

sum(dane_final$w*dane_final$b)/sum(dane_final$w)

summary(lm(y1 ~ x1, data=dane1))

```


$\beta=\frac{y_1-y_2}{x_1-x_2}$

Krótsze linie charakteryzują się większą zmiennością niż dłuższe. Stąd potrzeba wykorzystania wag.

$wij=(x_i-x_j)^2$

$\beta=\frac{\sum w_{ij}\beta}{\sum w_{ij}}$

$n(n-1)/2$

```{r}
library(survey)

data(election)

sum(election$Bush)

schemat <- svydesign(ids=~1, data=election_pps, weights = ~wt)

svytotal(x = ~Bush, design = schemat)

m <- svyglm(Bush~Kerry+Nader, schemat)
summary(m)

new_data <- data.frame(Kerry=sum(election$Kerry), Nader=sum(election$Nader))

predict(m, total = 4600, newdata = new_data)

m1 <- svyglm(Bush~Kerry+Nader, schemat, family = quasi(variance="mu"))
summary(m1)

predict(m1, total = 4600, newdata = new_data)


```

```{r}
data(api)


  dstrat<-svydesign(id=~1,strata=~stype, weights=~pw, data=apistrat, fpc=~fpc)
  dclus2<-svydesign(id=~dnum+snum, weights=~pw, data=apiclus2)
  rstrat<-as.svrepdesign(dstrat)
  rclus2<-as.svrepdesign(dclus2)

  summary(svyglm(api00~ell+meals+mobility, design=dstrat))
  summary(svyglm(api00~ell+meals+mobility, design=dclus2))
  summary(svyglm(api00~ell+meals+mobility, design=rstrat))
  summary(svyglm(api00~ell+meals+mobility, design=rclus2))

  ## use quasibinomial, quasipoisson to avoid warning messages
  summary(svyglm(sch.wide~ell+meals+mobility, design=dstrat,
        family=quasibinomial()))


  ## Compare regression and ratio estimation of totals
  api.ratio <- svyratio(~api.stu,~enroll, design=dstrat)
  pop<-data.frame(enroll=sum(apipop$enroll, na.rm=TRUE))
  npop <- nrow(apipop)
  predict(api.ratio, pop$enroll)

  ## regression estimator is less efficient
  api.reg <- svyglm(api.stu~enroll, design=dstrat)
  predict(api.reg, newdata=pop, total=npop)
  ## same as calibration estimator
  svytotal(~api.stu, calibrate(dstrat, ~enroll, pop=c(npop, pop$enroll)))

  ## svyglm can also reproduce the ratio estimator
  api.reg2 <- svyglm(api.stu~enroll-1, design=dstrat,
                    family=quasi(link="identity",var="mu"))
  predict(api.reg2, newdata=pop, total=npop)

  ## higher efficiency by modelling variance better
  api.reg3 <- svyglm(api.stu~enroll-1, design=dstrat,
                    family=quasi(link="identity",var="mu^3"))
  predict(api.reg3, newdata=pop, total=npop)
  ## true value
  sum(apipop$api.stu)

```

